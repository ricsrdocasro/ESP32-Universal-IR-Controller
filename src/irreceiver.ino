#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <EEPROM.h>
#include "PinDefinitionsAndMore.h"
#include <IRremote.hpp> // include the library

// Configurações do display
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// IR 
#define IR_RECEIVE_PIN 4  // Pino do receptor IR
#define IR_SEND_PIN   15      // Pino do transmissor IR

// EEPROM
#define EEPROM_SIZE 512 // Tamanho da EEPROM
#define EEPROM_START_ADDRESS 0  // Endereço inicial para armazenamento    

// Pinos dos botões
#define BUTTON_LEFT    34
#define BUTTON_SELECT  35
#define BUTTON_RIGHT   32

// IRremote
#define DECODE_DENON        // Includes Sharp
#define DECODE_JVC
#define DECODE_KASEIKYO
#define DECODE_PANASONIC    // alias for DECODE_KASEIKYO
#define DECODE_LG
#define DECODE_NEC          // Includes Apple and Onkyo. To enable all protocols , just comment/disable this line.
#define DECODE_SAMSUNG
#define DECODE_SONY
#define DECODE_RC5
#define DECODE_RC6
#define DECODE_BOSEWAVE
#define DECODE_LEGO_PF
#define DECODE_MAGIQUEST
#define DECODE_WHYNTER
#define DECODE_FAST
#define DECODE_DISTANCE_WIDTH // Universal decoder for pulse distance width protocols
#define DECODE_HASH             // special decoder for all protocols
#define RAW_BUFFER_LENGTH  1000 // Especially useful for unknown and probably long protocols

// Variáveis para armazenar o sinal recebido
struct storedIRDataStruct {
    IRData receivedIRData;
    // extensions for sendRaw
    uint8_t rawCode[RAW_BUFFER_LENGTH]; // The durations if raw
    uint8_t rawCodeLength; // The length of the code
} sStoredIRData;

bool sinalRecebido = false;          // Flag para indicar se um sinal foi recebido

#define DEBUG                 // Activate this for lots of lovely debug output from the decoders.

/*
* This include defines the actual pin number for pins like IR_RECEIVE_PIN, IR_SEND_PIN for many different boards and architectures
*/

const unsigned char PROGMEM capa[]= {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xd1, 0xe3, 0x27, 0xdf, 0x1f, 0x20, 0xf0, 0x42, 0x44, 0xa0, 0xbc, 0xf1, 0xe1, 0x84, 0x00, 
	0x01, 0x02, 0x13, 0x21, 0x11, 0x31, 0x20, 0x80, 0x42, 0x64, 0x91, 0x20, 0x89, 0x01, 0x84, 0x00, 
	0x01, 0x02, 0x12, 0xa1, 0x11, 0x20, 0xa0, 0x80, 0x42, 0x64, 0x91, 0x20, 0x89, 0x80, 0x44, 0x00, 
	0x01, 0x02, 0x12, 0xa1, 0x1e, 0x20, 0xa0, 0xf0, 0x42, 0x54, 0x8a, 0x3c, 0xf0, 0xe2, 0x44, 0x00, 
	0x01, 0x02, 0x12, 0x61, 0x11, 0x21, 0x20, 0x80, 0x42, 0x5c, 0x8a, 0x20, 0x98, 0x13, 0xe4, 0x00, 
	0x01, 0x02, 0x32, 0x61, 0x11, 0x11, 0x20, 0x80, 0x46, 0x4c, 0x8e, 0x20, 0x88, 0x16, 0x24, 0x00, 
	0x00, 0xf1, 0xe2, 0x21, 0x10, 0x8e, 0x3e, 0xf0, 0x3c, 0x44, 0x84, 0x3c, 0x85, 0xe4, 0x27, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xfc, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xfe, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xff, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x7f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x8d, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xce, 0xc1, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x83, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// definição de funções
void menu_de_acao(void);
void atualizar_display(void);
void receber_IR(void);
void mandar_IR(void);
void receber_sem_EEPROM(void);
void mandar_sem_EEPROM(void);
void clearEEPROM(void);

// Estado do menu
int menuIndex = 0;

const char* mainMenu[] = {"Receber Sinal IR", "Repetir Sinal IR"};

void setup() {
  Serial.begin(115200);

  EEPROM.begin(EEPROM_SIZE);

  pinMode(BUTTON_LEFT, INPUT);
  pinMode(BUTTON_SELECT, INPUT);
  pinMode(BUTTON_RIGHT, INPUT);

  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  IrSender.begin();

  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.setRotation(0); // Modo retrato
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.display();

  // Chama sub-rotina
  testdrawbitmap();
  // Inverte cores no display
  display.invertDisplay(true);
  // Aguarda 1 s
  delay(1000);
  // Volta às cores originais no display
  display.invertDisplay(false);
  // Aguarda 1 s
  delay(1000);

  display.clearDisplay();
  display.setCursor(0,0); 
  display.println("Menu Principal");
  display.println(" ");
  display.print(" > ");
  display.println(mainMenu[menuIndex]);
  display.display();
}

void loop() {
  atualizar_display();
 
  if(digitalRead(BUTTON_RIGHT) == LOW){
    while(digitalRead(BUTTON_RIGHT) == LOW);

    menuIndex++;

    if(menuIndex > 1){
      menuIndex = 0;
    }
  }

  if(digitalRead(BUTTON_LEFT) == LOW){
    while(digitalRead(BUTTON_LEFT) == LOW);

    menuIndex--;

    if(menuIndex < 0){
      menuIndex = 1;
    }
  }

  if(digitalRead(BUTTON_SELECT) == LOW){
    while(digitalRead(BUTTON_SELECT) == LOW);
    menu_de_acao();
  }
}

void menu_de_acao(){
  if(menuIndex == 0){
    display.clearDisplay();
    display.setCursor(24,32); 
    display.print("Recebendo IR...");
    display.display();
    receber_sem_EEPROM();
    //receber_IR();
  } else {
    display.clearDisplay();
    display.setCursor(24,32);
    display.print("Mandando IR...");
    display.display();
    mandar_sem_EEPROM();
    //mandar_IR();
  }
}

void atualizar_display(){
  display.clearDisplay();
  display.setCursor(0,0); 
  display.println("Menu Principal");
  display.println(" ");
  display.print(" > ");
  display.println(mainMenu[menuIndex]);
  display.display();
}

void receber_sem_EEPROM(){
  sinalRecebido = false;
  IrReceiver.resume();

  Serial.print("Sinal Recebido: ");
  Serial.println(sinalRecebido);
  
  while(!sinalRecebido){
    if (IrReceiver.decode()) {
      sinalRecebido = true;

      if (IrReceiver.decodedIRData.protocol == UNKNOWN) {
        Serial.println(F("Received noise or an unknown (or not yet enabled) protocol"));
        // We have an unknown protocol here, print extended info
        IrReceiver.printIRResultRawFormatted(&Serial, true);
        
        sStoredIRData.receivedIRData = IrReceiver.decodedIRData;

        IrReceiver.resume(); // Do it here, to preserve raw data for printing with printIRResultRawFormatted()
      } else if (IrReceiver.decodedIRData.protocol == NEC) {
        sStoredIRData.receivedIRData = IrReceiver.decodedIRData;

        // Parâmetros do protocolo NEC
        uint16_t address = IrReceiver.decodedIRData.address;
        uint8_t command = IrReceiver.decodedIRData.command;

        Serial.print("Endereço: 0x");
        Serial.print(address, HEX);
        Serial.print(" | Comando: 0x");
        Serial.println(command, HEX);
        IrReceiver.resume();

        // Armazene os valores de endereço e comando conforme necessário
      } else {
        sStoredIRData.receivedIRData = IrReceiver.decodedIRData;

        IrReceiver.resume(); // Early enable receiving of the next IR frame
        IrReceiver.printIRResultShort(&Serial);
        IrReceiver.printIRSendUsage(&Serial);
      }
    }

    Serial.print("Sinal Recebido: ");
    Serial.println(sinalRecebido);
  }
}

void mandar_sem_EEPROM(){
  Serial.print("Sinal Recebido: ");
  Serial.println(sinalRecebido);

  if (!sinalRecebido) {
    Serial.println("Nenhum sinal armazenado para enviar.");
    return;
  }

  auto tProtocol = IrReceiver.decodedIRData.protocol;
  if (tProtocol == UNKNOWN || tProtocol == PULSE_WIDTH || tProtocol == PULSE_DISTANCE || tProtocol == NEC) {
    Serial.println("Protocol: UNKNOWN, NEC or PULSE DISTANCE");
    // Assume 38 KHz
    IrSender.sendRaw(IrReceiver.decodedIRData.rawDataPtr->rawbuf, IrReceiver.decodedIRData.rawDataPtr->rawlen, 38);

    // Determinação da ordem dos bits
    bool isLsbFirst = !(IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_MSB_FIRST);
    uint8_t bitOrder = isLsbFirst ? PROTOCOL_IS_LSB_FIRST : PROTOCOL_IS_MSB_FIRST;

    // Extração dos parâmetros de temporização
    uint16_t headerMark = IrReceiver.decodedIRData.DistanceWidthTimingInfo.HeaderMarkMicros;
    uint16_t headerSpace = IrReceiver.decodedIRData.DistanceWidthTimingInfo.HeaderSpaceMicros;
    uint16_t oneMark = IrReceiver.decodedIRData.DistanceWidthTimingInfo.OneMarkMicros;
    uint16_t oneSpace = IrReceiver.decodedIRData.DistanceWidthTimingInfo.OneSpaceMicros;
    uint16_t zeroMark = IrReceiver.decodedIRData.DistanceWidthTimingInfo.ZeroMarkMicros;
    uint16_t zeroSpace = IrReceiver.decodedIRData.DistanceWidthTimingInfo.ZeroSpaceMicros;
    uint16_t bitCount = IrReceiver.decodedIRData.numberOfBits;

    // Parâmetros do protocolo NEC
    uint16_t address = IrReceiver.decodedIRData.address;
    uint8_t command = IrReceiver.decodedIRData.command;

    Serial.print("Endereço: 0x");
    Serial.print(address, HEX);
    Serial.print(" | Comando: 0x");
    Serial.println(command, HEX);

    // Dados brutos do sinal
    IRRawDataType* rawData = IrReceiver.decodedIRData.decodedRawDataArray;

    // Retransmissão do sinal em NEC
    IrSender.sendNEC(address, command, 2);

    // Retransmissão do sinal em Pulse Distance
    IrSender.sendPulseDistanceWidthFromArray(
      38, // Frequência em kHz
      headerMark, headerSpace,
      oneMark, oneSpace,
      zeroMark, zeroSpace,
      rawData, bitCount,
      bitOrder, // Ajuste conforme necessário
      0, // Período de repetição em milissegundos
      0  // Número de repetições
    );
  } else {
    Serial.print("Protocol: ");
    Serial.println(tProtocol);

    // Use the write function, which does the switch for different protocols
    IrSender.write(&sStoredIRData.receivedIRData);
    printIRResultShort(&Serial, &sStoredIRData.receivedIRData, true);
  }
}

void receber_IR(){
  bool recebido = false;
  
  while(!recebido){
    if(IrReceiver.decode()){
      recebido = true;
      Serial.println("Sinal IR recebido.");

      // Limpa a memória da EEPROM
      clearEEPROM();

      // Armazena o tamanho do sinal
      int length = IrReceiver.decodedIRData.rawDataPtr->rawlen;
      EEPROM.write(0, length);

      // Armazena os dados brutos na EEPROM
      for (int i = 0; i < length; i++) {
        uint16_t duration = IrReceiver.decodedIRData.rawDataPtr->rawbuf[i];
        EEPROM.write(1 + i * 2, duration & 0xFF);
        EEPROM.write(1 + i * 2 + 1, duration >> 8);
      }

      EEPROM.commit();
      Serial.println("Sinal armazenado na EEPROM.");
      IrReceiver.resume();  // Pronto para o próximo sinal
    }
  }
}

void mandar_IR(){
  Serial.println("Enviando sinal IR armazenado...");

  // Lê o tamanho do sinal
  int length = EEPROM.read(0);

  // Lê os dados brutos da EEPROM
  uint16_t rawData[length];

  for (int i = 0; i < length; i++) {
    uint8_t lowByte = EEPROM.read(1 + i * 2);
    uint8_t highByte = EEPROM.read(1 + i * 2 + 1);
    rawData[i] = (highByte << 8) | lowByte;
  }

  // Envia o sinal IR
  IrSender.sendRaw(rawData, length, 38);  // 38 kHz é a frequência padrão
  delay(500);  // Evita múltiplos envios
}

void clearEEPROM() {
  for (int i = EEPROM_START_ADDRESS; i < EEPROM_SIZE; i++) {
    EEPROM.write(i, 0xFF);
  }
  EEPROM.commit();  // Necessário para ESP32
}

void testdrawbitmap() {
  // Limpa display
  display.clearDisplay();
 
  // Preenche tela com bitmap
  display.drawBitmap(
	(display.width()  - 128 ) / 2,
	(display.height() - 64) / 2,
	capa, 128, 64, 1);
  // Exibe no display 
  display.display();
  // Aguarda 1 s
  delay(1000);
}